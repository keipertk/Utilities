import os
file_name = os.path.join("..", "utilities", "macros", "for_each.hpp")
depth = 25
max_args = 1

def print_n(f, start, end):
    for itr in range(start, end):
        f.write(" _{},".format(itr))

def print_fex_y(f, x, y):
    f.write("#define _fe{}_{}(_call,".format(x, y))
    print_n(f, 0, x+1)
    f.write(" ...)")

with open(file_name,'w') as f:
    f.write("#pragma once\n\n")
    f.write("/** @file ForEach.hpp\n")
    f.write(" *\n")
    f.write(" * This header file is auto-generated by MakeForEach.py\n")
    f.write(" * To allow more looping regenerate this file with a higher\n")
    f.write(" * value of \"depth\".\n")
    f.write(" *\n")
    f.write(" *  Includes C-Preprocessor macros for iterating over a list\n")
    f.write(" *  of arguments and applying a macro to them.  The contents of\n")
    f.write(" *  this header are borrowed from StackOverflow.\n")
    f.write(" *  Of the various macros in here only the following are\n")
    f.write(" *  intended for use:\n")
    f.write(" *  - CALL_MACRO_X_FOR_EACH : Calls a macro for each argument \n")
    f.write(" *    passed to the list\n")
    f.write(" *  - CALL_MACRO_X_FOR_EACH1: Calls a macro with one bound\n")
    f.write(" *    argument for each argument in the list\n")
    f.write(" */\n")

    f.write("/**\n")
    f.write(" * @brief Returns the N-th argument of a list.\n")
    f.write(" *\n")
    f.write(" * By padding what's to the left and what's to the right of\n")
    f.write(" * element N, this macro can be made to arbitrarily select an\n")
    f.write(" * element from a list.  To select say the third argument of a\n")
    f.write(" * list you simply put M-3 placeholders in front of it where M\n")
    f.write(" * is the maximum number written out here ({}).\n".format(depth))
    f.write(" */\n")
    f.write("#define _GET_NTH_ARG(")
    print_n(f, 1, depth+1)
    f.write(" N, ...) N\n\n")

    for i in range(max_args+1):
        f.write("/// Guts of the CALL_MACRO_X_FOR_EACH{} macro\n".format(i))
        f.write("///{\n")
        print_fex_y(f, i, 0)
        f.write("\n")
        print_fex_y(f, i, 1)
        f.write(" _call(")
        print_n(f, 0, i)
        f.write("_{})\n".format(i))
        for j in range(2, depth):
            print_fex_y(f, i, j)
            f.write(" _call(")
            print_n(f, 0, i)
            f.write("_{}) _fe{}_{}(_call, ".format(i, i, j-1))
            print_n(f, 0, i)
            f.write(" __VA_ARGS__)\n")
        f.write("///}\n\n")

    for i in range(max_args+1):
        f.write("/**\n")
        f.write(" * @brief Applies a macro to each argument in a list\n")
        f.write(" *\n")
        f.write(" * @param[in] x The macro to apply\n")
        for j in range(i):
            f.write(" * @param[in] _{} The {}-th argument to bind\n".format(
                j, j))
        f.write(" * @param[in] ... The list of arguments to apply @p x to\n")
        f.write(" */\n")
        if i ==0:
            f.write("#define CALL_MACRO_X_FOR_EACH(_call, ...)\ \n")
        else:
            f.write("#define CALL_MACRO_X_FOR_EACH{}(_call,".format(i))
            print_n(f, 0, i)
            f.write("...)\ \n")
        f.write("  _GET_NTH_ARG(\"ignored\", __VA_ARGS__,")
        for j in range(depth-1, 1, -1):
            f.write(" _fe{}_{},".format(i, j))
        f.write(" _fe{}_0)(_call,".format(i))
        print_n(f, 0, i)
        f.write(" __VA_ARGS__)\n")
